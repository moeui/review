## 执行上下文

概念：

    执行上下文是执行js代码环境的抽象概念，只要js代码运行，它就是在执行上下文中运行。执行上下文也可以叫做执行环境。

类型：

    1、全局执行上下文：只有一个，浏览器中的全局对象是window对象，this指向window对象。任何不在函数内部的代码都是在全局上下文中

    2、函数执行上下文：存在无数个，每当一个函数被调用时，都会创建一个新的函数执行上下文（不管这个函数是否重复调用）

    3、Eval函数执行上下文：执行eval函数内部的代码有自己的执行上下文，很少有且不建议使用。

生命周期：

    创建阶段 -- 执行阶段 -- 回收阶段

    创建阶段，被调用但未执行前，做了三件事：
        1、确定this的值（this绑定）

            this的值是在执行的时候才能确认的，全局执行上下文执行全局对象window，函数执行上下文取决于是如何被调用的。如：
                let foo = {
                    baz: function() {
                        console.log(this);
                    }
                }
                foo.baz();  // this 指向 foo, 因为baz被对象foo调用
                let bar = foo.baz;
                bar();  // this指向window对象，因为没有指定引用对象(严格模式下是undefined)
        2、创建词法环境(LexicalEnvironment)组件

            分为全局环境和函数环境，在全局环境中，环境记录器是对象环境记录器，在函数环境中，环境记录器是声明式环境记录器。

        3、创建变量环境(VariableEnvironment)组件

            也是一个词法环境，其具有词法环境所有的属性，不同的是在es6中，词法环境用来储存函数声明和变量（let、const）绑定,变量环境只用来储存var变量绑定。

    执行阶段：
        在这个阶段，执行变量赋值分配，最后执行代码。

        注：如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined

    回收阶段：
        当函数执行完成后，当前执行上下文（局部环境）会被弹出执行上下文栈并且销毁，控制权被重新交给执行栈上一层的执行上下文。（闭包不会回收）

以上基于ES6，会有出入


## 作用域和执行上下文的区别

     执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。
     
    一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。


## 暂停性死区(TDZ)

代码块中使用let或const，从一开始就形成了封闭的作用域，在声明前不可用，语法上称为暂停性死区。

```js
    var tmp = 'test'
    if(true) {
        tmp = 'test2' // ReferenceError
        let tmp
    }
```


[资料1](https://juejin.cn/post/6844903682283143181)

[资料2](https://juejin.cn/post/6844904158957404167)