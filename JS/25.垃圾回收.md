## JavaScript中的内存管理

浏览器的垃圾回收（GC）是 JavaScript 引擎自动管理内存的核心机制。它的目标是：自动释放不再使用的内存，防止内存泄漏。开发者无需手动释放变量占用的内存。

- 核心原理是js引擎判断一个值是否从根开始是具有可访问性（简单说：“没人能找到你了，你就该被清理了。）

  ```js
    // 申请内存
    let obj = {}
    // 使用内存
    obj.name = 'lg'
    // 释放内存 js中没有释放api，我们这里就把它设置为null
    obj = null
  ```

垃圾回收（GC）：找出不再使用的变量，然后释放掉其占用的内存，这个过程不是实时的，因为开销比较大，垃圾回收器会按照固定的时间周期执行

- 引用计数

  是最初级的垃圾收集算法，简化的定义为“对象有没有被其他对象引用”，零引用被回收

  ```js
    function test(){
      var a = {} ; //a的引用次数为0
      var b = a ; //a的引用次数加1，为1
      var c =a; //a的引用次数再加1，为2
      var b ={}; //a的引用次数减1，为1
    }
  ```
  优点：引用计数为零时，发现垃圾立即回收；最大限度减少程序暂停；

  缺点： 无法回收循环引用的对象，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。空间开销比较大
  
- 标记整理清除

  对象不能从根（window）上访问到

  ```js
    function test(){
      var a = 10 ; //被标记 ，进入环境
      var b = 20 ; //被标记 ，进入环境
    }
    test(); //执行完毕 之后 a、b又被标离开环境，被回收。
  ```


### 补充

GC 只能回收“不可达”对象，但以下情况会让本该回收的对象保持可达：

| 场景 | 说明 | 解决方案 |
|------|------|--------|
| 全局变量 | 意外创建全局变量（如漏写 `let/const`） | 使用严格模式；避免挂载到 `window` |
| 定时器/回调未清理 | `setInterval` 引用组件内部函数 | 组件卸载时 `clearInterval` |
| 闭包持有引用 | 内部函数引用外部大对象 | 避免不必要的闭包引用 |
| DOM 引用未解绑 | 保存了已移除 DOM 节点的引用 | 移除节点时清空引用 |
| 缓存无上限 | Map/Set 不断增长 | 使用 WeakMap/WeakSet（弱引用） |

